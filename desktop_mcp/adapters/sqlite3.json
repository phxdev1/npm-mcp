{
  "package": "sqlite3",
  "import_type": "python",
  "description": "SQLite database operations and data management",
  "capabilities": ["database", "data_storage", "sql"],
  "setup": [
    "import sqlite3",
    "import json",
    "import os"
  ],
  "methods": {
    "create_database": {
      "description": "Create or connect to SQLite database",
      "parameters": ["database_path"],
      "code": [
        "database_path = params.get('database_path')",
        "try:",
        "    conn = sqlite3.connect(database_path)",
        "    conn.close()",
        "    result = {",
        "        'success': True,",
        "        'database_path': database_path,",
        "        'exists': os.path.exists(database_path),",
        "        'message': 'Database created/connected successfully'",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e), 'database_path': database_path}",
        "return result"
      ]
    },
    "execute_query": {
      "description": "Execute SQL query and return results",
      "parameters": ["database_path", "query", "parameters?"],
      "code": [
        "database_path = params.get('database_path')",
        "query = params.get('query')",
        "parameters = params.get('parameters', [])",
        "try:",
        "    conn = sqlite3.connect(database_path)",
        "    conn.row_factory = sqlite3.Row",
        "    cursor = conn.cursor()",
        "    if parameters:",
        "        cursor.execute(query, parameters)",
        "    else:",
        "        cursor.execute(query)",
        "    if query.strip().upper().startswith('SELECT'):",
        "        rows = cursor.fetchall()",
        "        result_data = [dict(row) for row in rows]",
        "        result = {",
        "            'success': True,",
        "            'query': query,",
        "            'rows': result_data,",
        "            'row_count': len(result_data)",
        "        }",
        "    else:",
        "        conn.commit()",
        "        result = {",
        "            'success': True,",
        "            'query': query,",
        "            'rows_affected': cursor.rowcount,",
        "            'message': 'Query executed successfully'",
        "        }",
        "    conn.close()",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e), 'query': query}",
        "return result"
      ]
    },
    "create_table": {
      "description": "Create a table with specified columns",
      "parameters": ["database_path", "table_name", "columns"],
      "code": [
        "database_path = params.get('database_path')",
        "table_name = params.get('table_name')",
        "columns = params.get('columns')",
        "if isinstance(columns, dict):",
        "    column_definitions = []",
        "    for col_name, col_type in columns.items():",
        "        column_definitions.append(f'{col_name} {col_type}')",
        "    columns_sql = ', '.join(column_definitions)",
        "else:",
        "    columns_sql = ', '.join(columns)",
        "query = f'CREATE TABLE IF NOT EXISTS {table_name} ({columns_sql})'",
        "try:",
        "    conn = sqlite3.connect(database_path)",
        "    cursor = conn.cursor()",
        "    cursor.execute(query)",
        "    conn.commit()",
        "    conn.close()",
        "    result = {",
        "        'success': True,",
        "        'table_name': table_name,",
        "        'columns': columns,",
        "        'query': query,",
        "        'message': 'Table created successfully'",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e), 'table_name': table_name}",
        "return result"
      ]
    },
    "insert_data": {
      "description": "Insert data into a table",
      "parameters": ["database_path", "table_name", "data"],
      "code": [
        "database_path = params.get('database_path')",
        "table_name = params.get('table_name')",
        "data = params.get('data')",
        "try:",
        "    conn = sqlite3.connect(database_path)",
        "    cursor = conn.cursor()",
        "    if isinstance(data, dict):",
        "        columns = ', '.join(data.keys())",
        "        placeholders = ', '.join(['?' for _ in data])",
        "        query = f'INSERT INTO {table_name} ({columns}) VALUES ({placeholders})'",
        "        cursor.execute(query, list(data.values()))",
        "        inserted_rows = 1",
        "    elif isinstance(data, list) and all(isinstance(row, dict) for row in data):",
        "        if data:",
        "            columns = ', '.join(data[0].keys())",
        "            placeholders = ', '.join(['?' for _ in data[0]])",
        "            query = f'INSERT INTO {table_name} ({columns}) VALUES ({placeholders})'",
        "            values_list = [list(row.values()) for row in data]",
        "            cursor.executemany(query, values_list)",
        "            inserted_rows = len(data)",
        "        else:",
        "            result = {'success': False, 'error': 'Empty data list provided'}",
        "            return result",
        "    else:",
        "        result = {'success': False, 'error': 'Data must be a dictionary or list of dictionaries'}",
        "        return result",
        "    conn.commit()",
        "    conn.close()",
        "    result = {",
        "        'success': True,",
        "        'table_name': table_name,",
        "        'rows_inserted': inserted_rows,",
        "        'message': f'Inserted {inserted_rows} row(s) successfully'",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e), 'table_name': table_name}",
        "return result"
      ]
    },
    "get_table_info": {
      "description": "Get information about a table",
      "parameters": ["database_path", "table_name"],
      "code": [
        "database_path = params.get('database_path')",
        "table_name = params.get('table_name')",
        "try:",
        "    conn = sqlite3.connect(database_path)",
        "    cursor = conn.cursor()",
        "    cursor.execute(f'PRAGMA table_info({table_name})')",
        "    columns_info = cursor.fetchall()",
        "    cursor.execute(f'SELECT COUNT(*) FROM {table_name}')",
        "    row_count = cursor.fetchone()[0]",
        "    conn.close()",
        "    columns = []",
        "    for col in columns_info:",
        "        columns.append({",
        "            'name': col[1],",
        "            'type': col[2],",
        "            'not_null': bool(col[3]),",
        "            'default_value': col[4],",
        "            'primary_key': bool(col[5])",
        "        })",
        "    result = {",
        "        'success': True,",
        "        'table_name': table_name,",
        "        'columns': columns,",
        "        'row_count': row_count,",
        "        'column_count': len(columns)",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e), 'table_name': table_name}",
        "return result"
      ]
    },
    "list_tables": {
      "description": "List all tables in the database",
      "parameters": ["database_path"],
      "code": [
        "database_path = params.get('database_path')",
        "try:",
        "    conn = sqlite3.connect(database_path)",
        "    cursor = conn.cursor()",
        "    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")",
        "    tables = [row[0] for row in cursor.fetchall()]",
        "    conn.close()",
        "    result = {",
        "        'success': True,",
        "        'database_path': database_path,",
        "        'tables': tables,",
        "        'table_count': len(tables)",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e), 'database_path': database_path}",
        "return result"
      ]
    },
    "backup_database": {
      "description": "Create a backup of the database",
      "parameters": ["source_database", "backup_path"],
      "code": [
        "source_database = params.get('source_database')",
        "backup_path = params.get('backup_path')",
        "try:",
        "    source_conn = sqlite3.connect(source_database)",
        "    backup_conn = sqlite3.connect(backup_path)",
        "    source_conn.backup(backup_conn)",
        "    source_conn.close()",
        "    backup_conn.close()",
        "    backup_size = os.path.getsize(backup_path)",
        "    result = {",
        "        'success': True,",
        "        'source_database': source_database,",
        "        'backup_path': backup_path,",
        "        'backup_size_bytes': backup_size,",
        "        'message': 'Database backup created successfully'",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e)}",
        "return result"
      ]
    },
    "export_to_json": {
      "description": "Export table data to JSON file",
      "parameters": ["database_path", "table_name", "json_file_path"],
      "code": [
        "database_path = params.get('database_path')",
        "table_name = params.get('table_name')",
        "json_file_path = params.get('json_file_path')",
        "try:",
        "    conn = sqlite3.connect(database_path)",
        "    conn.row_factory = sqlite3.Row",
        "    cursor = conn.cursor()",
        "    cursor.execute(f'SELECT * FROM {table_name}')",
        "    rows = cursor.fetchall()",
        "    data = [dict(row) for row in rows]",
        "    conn.close()",
        "    with open(json_file_path, 'w') as f:",
        "        json.dump(data, f, indent=2, default=str)",
        "    result = {",
        "        'success': True,",
        "        'table_name': table_name,",
        "        'json_file_path': json_file_path,",
        "        'rows_exported': len(data),",
        "        'message': f'Exported {len(data)} rows to JSON'",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e)}",
        "return result"
      ]
    }
  }
}