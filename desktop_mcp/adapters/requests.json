{
  "package": "requests",
  "import_type": "python",
  "description": "HTTP requests and web API integration",
  "capabilities": ["network", "api_integration", "web_services"],
  "setup": [
    "import requests",
    "import json",
    "import base64"
  ],
  "methods": {
    "http_get": {
      "description": "Send HTTP GET request",
      "parameters": ["url", "headers?", "params?", "timeout?=30", "verify_ssl?=true"],
      "code": [
        "url = params.get('url')",
        "headers = params.get('headers', {})",
        "query_params = params.get('params', {})",
        "timeout = params.get('timeout', 30)",
        "verify_ssl = params.get('verify_ssl', True)",
        "try:",
        "    response = requests.get(url, headers=headers, params=query_params, timeout=timeout, verify=verify_ssl)",
        "    result = {",
        "        'success': True,",
        "        'status_code': response.status_code,",
        "        'headers': dict(response.headers),",
        "        'text': response.text,",
        "        'url': response.url,",
        "        'elapsed_seconds': response.elapsed.total_seconds()",
        "    }",
        "    try:",
        "        result['json'] = response.json()",
        "    except:",
        "        result['json'] = None",
        "except requests.exceptions.Timeout:",
        "    result = {'success': False, 'error': 'Request timed out', 'timeout': timeout}",
        "except requests.exceptions.ConnectionError:",
        "    result = {'success': False, 'error': 'Connection error'}",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e)}",
        "return result"
      ]
    },
    "http_post": {
      "description": "Send HTTP POST request",
      "parameters": ["url", "data?", "json_data?", "headers?", "timeout?=30"],
      "code": [
        "url = params.get('url')",
        "data = params.get('data')",
        "json_data = params.get('json_data')",
        "headers = params.get('headers', {})",
        "timeout = params.get('timeout', 30)",
        "try:",
        "    if json_data:",
        "        response = requests.post(url, json=json_data, headers=headers, timeout=timeout)",
        "    else:",
        "        response = requests.post(url, data=data, headers=headers, timeout=timeout)",
        "    result = {",
        "        'success': True,",
        "        'status_code': response.status_code,",
        "        'headers': dict(response.headers),",
        "        'text': response.text,",
        "        'url': response.url",
        "    }",
        "    try:",
        "        result['json'] = response.json()",
        "    except:",
        "        result['json'] = None",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e)}",
        "return result"
      ]
    },
    "download_file": {
      "description": "Download a file from URL",
      "parameters": ["url", "local_path", "headers?", "chunk_size?=8192"],
      "code": [
        "url = params.get('url')",
        "local_path = params.get('local_path')",
        "headers = params.get('headers', {})",
        "chunk_size = params.get('chunk_size', 8192)",
        "try:",
        "    response = requests.get(url, headers=headers, stream=True)",
        "    response.raise_for_status()",
        "    total_size = 0",
        "    with open(local_path, 'wb') as f:",
        "        for chunk in response.iter_content(chunk_size=chunk_size):",
        "            if chunk:",
        "                f.write(chunk)",
        "                total_size += len(chunk)",
        "    result = {",
        "        'success': True,",
        "        'local_path': local_path,",
        "        'size_bytes': total_size,",
        "        'content_type': response.headers.get('content-type'),",
        "        'status_code': response.status_code",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e), 'url': url}",
        "return result"
      ]
    },
    "webhook_send": {
      "description": "Send data to a webhook URL",
      "parameters": ["webhook_url", "payload", "method?=POST"],
      "code": [
        "webhook_url = params.get('webhook_url')",
        "payload = params.get('payload')",
        "method = params.get('method', 'POST').upper()",
        "headers = {'Content-Type': 'application/json'}",
        "try:",
        "    if method == 'POST':",
        "        response = requests.post(webhook_url, json=payload, headers=headers)",
        "    elif method == 'PUT':",
        "        response = requests.put(webhook_url, json=payload, headers=headers)",
        "    else:",
        "        result = {'success': False, 'error': f'Unsupported method: {method}'}",
        "        return result",
        "    result = {",
        "        'success': True,",
        "        'status_code': response.status_code,",
        "        'response_text': response.text,",
        "        'webhook_url': webhook_url",
        "    }",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e)}",
        "return result"
      ]
    },
    "api_call": {
      "description": "Generic API call with authentication",
      "parameters": ["url", "method?=GET", "headers?", "data?", "auth_token?", "api_key?"],
      "code": [
        "url = params.get('url')",
        "method = params.get('method', 'GET').upper()",
        "headers = params.get('headers', {})",
        "data = params.get('data')",
        "auth_token = params.get('auth_token')",
        "api_key = params.get('api_key')",
        "if auth_token:",
        "    headers['Authorization'] = f'Bearer {auth_token}'",
        "if api_key:",
        "    headers['X-API-Key'] = api_key",
        "try:",
        "    if method == 'GET':",
        "        response = requests.get(url, headers=headers, params=data)",
        "    elif method == 'POST':",
        "        response = requests.post(url, headers=headers, json=data)",
        "    elif method == 'PUT':",
        "        response = requests.put(url, headers=headers, json=data)",
        "    elif method == 'DELETE':",
        "        response = requests.delete(url, headers=headers)",
        "    else:",
        "        result = {'success': False, 'error': f'Unsupported method: {method}'}",
        "        return result",
        "    result = {",
        "        'success': response.status_code < 400,",
        "        'status_code': response.status_code,",
        "        'headers': dict(response.headers),",
        "        'text': response.text,",
        "        'method': method,",
        "        'url': url",
        "    }",
        "    try:",
        "        result['json'] = response.json()",
        "    except:",
        "        result['json'] = None",
        "except Exception as e:",
        "    result = {'success': False, 'error': str(e)}",
        "return result"
      ]
    },
    "check_website_status": {
      "description": "Check if a website is accessible",
      "parameters": ["url", "timeout?=10"],
      "code": [
        "url = params.get('url')",
        "timeout = params.get('timeout', 10)",
        "try:",
        "    response = requests.get(url, timeout=timeout)",
        "    result = {",
        "        'url': url,",
        "        'accessible': True,",
        "        'status_code': response.status_code,",
        "        'response_time_ms': response.elapsed.total_seconds() * 1000,",
        "        'status': 'online'",
        "    }",
        "except requests.exceptions.Timeout:",
        "    result = {'url': url, 'accessible': False, 'status': 'timeout', 'error': 'Request timed out'}",
        "except requests.exceptions.ConnectionError:",
        "    result = {'url': url, 'accessible': False, 'status': 'connection_error', 'error': 'Connection failed'}",
        "except Exception as e:",
        "    result = {'url': url, 'accessible': False, 'status': 'error', 'error': str(e)}",
        "return result"
      ]
    }
  }
}